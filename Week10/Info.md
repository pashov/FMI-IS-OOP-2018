**Указатели към функции**

В курса по УП разгледахме указателите като ги насочвахме към променливи.

int b = 10;

int* a = &b;

Казваме, че указателят а сочи към адреса на b.

int func() 

{

return 100;

}

cout << func << endl;

След като принт-нем "func", a не "func()", ще получим адрес, който всъщност сочи адреса на кода на функцията в паметта. (не при всички компилатори)

Съответно:

int (*functionPtr)(); 

Е указател към функция, връщаща резултат от тип int и приемаща 0 аргументи. Може да се насочи към всяка функция с тези две свойства. (скобите са задължителни!)

functionPtr = func;

Така насочихме указателя към по-горната ни функция.

functionPtr();

ще извика func през functionPtr.

double area(int a, int b) 

{

return a*b;

}



functionPtr = area;

Няма да работи, защото area не е от тип, който има указателя, a също така има различен брой аргументи.



Указател на функция като параметър на функция.

Нищо сложно.

void sort(int[] array, int size, bool (*comparatorFunc) (int, int))

{

for (int i = 0; i < size - 1; i++) 

{

for (int j = i + 1; j < size; j++) 

{

if (comparatorFunc(array[i], array[j])

{

swap(array[i], array[j]);

}}}}



Съответно "comparatorFunc" може да е 

bool ascending(int a, int b) 

{

return a > b;

}

или

bool descending(int a, int b) 

{

return a < b;
}



Като самото извикване на сортировката би било

int array[] = { 1,6,1,3,2,1,155};

sort(array, 7, ascending);

или

sort(array, 7, descending);



Всъщност, вместо да пишем два различни метода за сортиране, ние написахме една абстрактна имплементация, която може да бъде използвана в различни случаи.